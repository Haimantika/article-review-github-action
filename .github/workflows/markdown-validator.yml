name: Markdown Checker

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.md'
  workflow_dispatch:

jobs:
  check-markdown:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm install axios
          
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v41
        with:
          files: |
            **/*.md
          files_ignore: |
            **/node_modules/**
            
      - name: Create format checker script
        run: |
          cat > format-checker.js << 'EOF'
          #!/usr/bin/env node
          
          const fs = require('fs');
          const path = require('path');
          
          // Validate headers structure (should follow proper hierarchy)
          const validateHeaderStructure = (filePath) => {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            const headerLevels = [];
            const yamlSection = content.startsWith('---');
            let inYamlSection = yamlSection;
            let valid = true;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Skip YAML front matter
              if (line === '---') {
                inYamlSection = !inYamlSection;
                continue;
              }
              
              if (inYamlSection) {
                continue;
              }
              
              // Check if line is a header
              if (line.startsWith('#')) {
                const level = line.match(/^#+/)[0].length;
                
                // First header should be level 1 or 2
                if (headerLevels.length === 0 && level > 2) {
                  console.error(`❌ ${filePath}:${i+1}: First header should be level 1 or 2, found level ${level}`);
                  valid = false;
                }
                
                // Headers should not skip levels (e.g., H2 -> H4)
                if (headerLevels.length > 0 && level > headerLevels[headerLevels.length - 1] + 1) {
                  console.error(`❌ ${filePath}:${i+1}: Header level skipped from ${headerLevels[headerLevels.length - 1]} to ${level}`);
                  valid = false;
                }
                
                // Check header format: exactly one space after #
                const headerFormat = line.match(/^#+\s/);
                if (!headerFormat || line.match(/^#+\s\s+/)) {
                  console.error(`❌ ${filePath}:${i+1}: Header format error: should have exactly one space after #: "${line}"`);
                  valid = false;
                }
                
                headerLevels.push(level);
              }
            }
            
            return valid;
          };
          
          // Check for trailing whitespace and extra spaces
          const validateWhitespace = (filePath) => {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            let valid = true;
            let inCodeBlock = false;
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Check for trailing whitespace
              if (line.match(/\s+$/)) {
                console.error(`❌ ${filePath}:${i+1}: Line has trailing whitespace: "${line}"`);
                valid = false;
              }
              
              // Check for multiple spaces in text
              // Track if we're inside a code block
              if (line.trim().startsWith('```')) {
                inCodeBlock = !inCodeBlock;
              }
              
              // Only check for multiple spaces if we're not in a code block, table, or special formatting
              if (!inCodeBlock && 
                  !line.startsWith('    ') && 
                  !line.startsWith('```') && 
                  !line.match(/^#+\s/) && 
                  !line.match(/^\s*-\s/) && 
                  !line.match(/^\|/) && 
                  !line.includes('[secondary_label') && 
                  !line.includes('  Running')) {
                  // Check for multiple spaces between words (3 or more)
                  if (line.match(/\S\s{3,}\S/)) {
                    console.error(`❌ ${filePath}:${i+1}: Line has excessive spaces (3+): "${line}"`);
                    valid = false;
                  }
              }
            }
            
            // Check if file ends with a single newline
            if (!content.endsWith('\n') || content.endsWith('\n\n')) {
              console.error(`❌ ${filePath}: File should end with a single newline character`);
              valid = false;
            }
            
            return valid;
          };
          
          // Main function
          const main = () => {
            try {
              // Get file from command line
              const file = process.argv[2];
              
              if (!file) {
                console.error('Please provide a file path as an argument');
                process.exit(1);
              }
              
              console.log(`Checking format of ${file}...`);
              
              // Run validations
              const headerValid = validateHeaderStructure(file);
              const whitespaceValid = validateWhitespace(file);
              
              if (headerValid && whitespaceValid) {
                console.log(`✅ ${file}: Format check passed`);
                process.exit(0);
              } else {
                console.error(`❌ ${file}: Format check failed`);
                process.exit(1);
              }
            } catch (error) {
              console.error('❌ Error:', error.message);
              process.exit(1);
            }
          };
          
          // Run the main function
          main();
          EOF
          
          chmod +x format-checker.js
            
      - name: Create grammar checker script
        run: |
          cat > check-grammar.js << 'EOF'
          #!/usr/bin/env node
          
          const fs = require('fs');
          const axios = require('axios');
          
          // DigitalOcean AI Agent endpoint and key
          const AGENT_BASE_URL = process.env.DO_AGENT_BASE_URL;
          const AGENT_ENDPOINT = `${AGENT_BASE_URL}/api/v1/chat/completions`;
          const API_TOKEN = process.env.DO_API_TOKEN;
          
          // Log information without revealing the full endpoint
          console.log("Grammar checking service initialized");
          
          if (!API_TOKEN) {
            console.error('❌ Error: API token not found. Please check environment variables.');
            process.exit(1);
          }
          
          if (!AGENT_BASE_URL) {
            console.error('❌ Error: Agent base URL not found. Please check environment variables.');
            process.exit(1);
          }
          
          // Extract plain text content from markdown
          const extractTextFromMarkdown = (content) => {
            // Remove YAML front matter
            let text = content;
            if (content.startsWith('---')) {
              const endOfFrontMatter = content.indexOf('---', 3);
              if (endOfFrontMatter !== -1) {
                text = content.slice(endOfFrontMatter + 3);
              }
            }
            
            // Remove code blocks and other markdown elements
            text = text.replace(/```[\s\S]*?```/g, '');
            text = text.replace(/<[^>]*>/g, '');
            text = text.replace(/\[([^\]]+)\]\([^)]+\)/g, '$1');
            text = text.replace(/!\[[^\]]*\]\([^)]+\)/g, '');
            
            return text;
          };
          
          // Function to check grammar using DigitalOcean's AI Agent
          const checkGrammar = async (text) => {
            try {
              console.log("Starting grammar analysis...");
              
              const payloadData = {
                model: "claude-3.5-sonnet",
                messages: [
                  {
                    role: "system",
                    content: "You are a skilled editor focused on identifying grammatical errors, typos, incorrect sentence structures, passive voice, and unnecessary jargon."
                  },
                  {
                    role: "user",
                    content: `Please review the following text for grammatical errors, typos, incorrect sentence structures, passive voice, and unnecessary jargon. For each issue, identify the specific problem, explain why it's an issue, and suggest a correction. Format your response as a JSON array with objects containing: "issue_type", "text_with_issue", "explanation", and "suggestion". Only identify actual issues. If there are no grammatical problems, return an empty array.\n\nText to review:\n${text}`
                  }
                ],
                temperature: 0.0,
                max_tokens: 1024
              };
              
              const response = await axios.post(AGENT_ENDPOINT, payloadData, {
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${API_TOKEN}`
                }
              });
              
              console.log("Analysis complete");
              
              // Parse the AI response to get the JSON data
              const aiResponse = response.data.choices[0].message.content;
              
              try {
                // Extract JSON from the response
                const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                return jsonMatch ? JSON.parse(jsonMatch[0]) : [];
              } catch (e) {
                console.error('❌ Error parsing AI response');
                return [];
              }
            } catch (error) {
              console.error('❌ Error checking grammar:', error.message);
              if (error.response) {
                console.error('Response status:', error.response.status);
                console.error('Error: Grammar service returned an error');
              }
              return [];
            }
          };
          
          // Process a single markdown file
          const processFile = async (filePath) => {
            try {
              console.log(`\nChecking grammar in ${filePath}...`);
              
              // Check if file exists
              if (!fs.existsSync(filePath)) {
                console.error(`❌ Error: File does not exist: ${filePath}`);
                return false;
              }
              
              const content = fs.readFileSync(filePath, 'utf8');
              const textToCheck = extractTextFromMarkdown(content);
              
              // Skip empty files or files with very little text content
              if (textToCheck.trim().length < 50) {
                console.log(`⚠️ Skipping ${filePath}: Not enough text content to check`);
                return true;
              }
              
              console.log(`Analyzing content...`);
              
              const issues = await checkGrammar(textToCheck);
              
              if (issues.length === 0) {
                console.log(`✅ ${filePath}: No grammar issues found`);
                return true;
              } else {
                console.log(`⚠️ ${filePath}: Found ${issues.length} grammar issues:`);
                issues.forEach((issue, index) => {
                  console.log(`  ${index + 1}. ${issue.issue_type}: "${issue.text_with_issue}"`);
                  console.log(`     Explanation: ${issue.explanation}`);
                  console.log(`     Suggestion: ${issue.suggestion}`);
                });
                return false;
              }
            } catch (error) {
              console.error(`❌ Error processing ${filePath}:`, error.message);
              return false;
            }
          };
          
          // Main function
          const main = async () => {
            try {
              // Get file from command line
              const file = process.argv[2];
              
              if (!file) {
                console.error('Please provide a file path as an argument');
                process.exit(1);
              }
              
              const result = await processFile(file);
              
              if (result) {
                console.log('\n✅ Grammar check passed');
                process.exit(0);
              } else {
                console.error('\n❌ Grammar check failed: Issues were found');
                process.exit(1);
              }
            } catch (error) {
              console.error('❌ Error:', error.message);
              process.exit(1);
            }
          };
          
          // Run the main function
          main();
          EOF
          
          chmod +x check-grammar.js

      - name: Run checks on changed files
        env:
          DO_API_TOKEN: ${{ secrets.DO_API_TOKEN }}
          DO_AGENT_BASE_URL: ${{ secrets.DO_AGENT_BASE_URL }}
        run: |
          if [ "${{ steps.changed-files.outputs.all_changed_files }}" == "" ]; then
            echo "No markdown files changed in this PR. Skipping checks."
            exit 0
          fi
          
          echo "Running checks on changed markdown files..."
          
          for file in ${{ steps.changed-files.outputs.all_changed_files }}; do
            echo ""
            echo "==== Checking $file ===="
            
            # Run format checker first
            echo ""
            echo "--- Format Check ---"
            node format-checker.js "$file" || FORMAT_FAILED=true
            
            # Run grammar checker regardless of format result
            echo ""
            echo "--- Grammar Check ---"
            node check-grammar.js "$file" || GRAMMAR_FAILED=true
            
            echo ""
          done
          
          # Report overall status
          echo ""
          echo "==== Check Summary ===="
          
          if [ "$FORMAT_FAILED" = true ]; then
            echo "❌ Format validation failed for one or more files"
          else
            echo "✅ Format validation passed for all files"
          fi
          
          if [ "$GRAMMAR_FAILED" = true ]; then
            echo "❌ Grammar check failed for one or more files"
          else
            echo "✅ Grammar check passed for all files"
          fi
          
          # Exit with error code if any check failed
          if [ "$FORMAT_FAILED" = true ] || [ "$GRAMMAR_FAILED" = true ]; then
            exit 1
          fi