name: Markdown Checker

on:
  pull_request:
    types: [opened, synchronize, reopened]
    paths:
      - '**.md'
  workflow_dispatch:

jobs:
  check-markdown:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm install axios
          
      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v41
        with:
          files: |
            **/*.md
          files_ignore: |
            **/node_modules/**
            
      - name: Create format checker script
        run: |
          cat > format-checker.js << 'EOF'
          #!/usr/bin/env node
          
          const fs = require('fs');
          const path = require('path');
          
          // Validate headers structure (should follow proper hierarchy)
          const validateHeaderStructure = (filePath) => {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            const headerLevels = [];
            const yamlSection = content.startsWith('---');
            let inYamlSection = yamlSection;
            let valid = true;
            
            console.log(`Checking header structure in ${filePath}...`);
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Skip YAML front matter
              if (line === '---') {
                inYamlSection = !inYamlSection;
                continue;
              }
              
              if (inYamlSection) {
                continue;
              }
              
              // Check if line is a header
              if (line.startsWith('#')) {
                const level = line.match(/^#+/)[0].length;
                console.log(`Found header level ${level} at line ${i+1}: ${line}`);
                
                // First header should be level 1 or 2
                if (headerLevels.length === 0 && level > 2) {
                  console.error(`❌ ${filePath}:${i+1}: First header should be level 1 or 2, found level ${level}`);
                  valid = false;
                }
                
                // Check previous header level if exists
                if (headerLevels.length > 0) {
                  const prevLevel = headerLevels[headerLevels.length - 1];
                  
                  // Headers should not skip levels (e.g., H2 -> H4)
                  if (level > prevLevel + 1) {
                    console.error(`❌ ${filePath}:${i+1}: Header level skipped from ${prevLevel} to ${level}`);
                    valid = false;
                  }
                  
                  // Headers should follow proper hierarchy (e.g., H3 -> H2 is not proper for subsections)
                  if (level < prevLevel && level !== 1 && level !== 2) {
                    // Allow jumping back to level 1 or 2 (new major section)
                    // But otherwise maintain proper hierarchy
                    console.error(`❌ ${filePath}:${i+1}: Improper header hierarchy: H${prevLevel} followed by H${level}`);
                    valid = false;
                  }
                }
                
                headerLevels.push(level);
              }
            }
            
            if (headerLevels.length === 0) {
              console.warn(`⚠️ ${filePath}: No headers found in document`);
            }
            
            return valid;
          };
          
          // Check for trailing whitespace and extra spaces
          const validateWhitespace = (filePath) => {
            const content = fs.readFileSync(filePath, 'utf8');
            const lines = content.split('\n');
            let valid = true;
            let inCodeBlock = false;
            
            console.log(`Checking whitespace in ${filePath}...`);
            
            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Check for trailing whitespace (visualize it in logs)
              if (line.match(/\s+$/)) {
                // For debugging, show the trailing spaces visually
                const visibleSpaces = line.r